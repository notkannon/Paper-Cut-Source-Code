-- Compiled with roblox-ts v1.2.7
local TS = _G[script]
local RunService = TS.import(script, TS.getModule(script, "@rbxts", "services")).RunService
local SignalConnection
do
	SignalConnection = setmetatable({}, {
		__tostring = function()
			return "SignalConnection"
		end,
	})
	SignalConnection.__index = SignalConnection
	function SignalConnection.new(...)
		local self = setmetatable({}, SignalConnection)
		return self:constructor(...) or self
	end
	function SignalConnection:constructor(disconnectCallback)
		self.Connected = true
		self.disconnectCallback = disconnectCallback
	end
	function SignalConnection:Disconnect()
		if not self.Connected then
			return nil
		end
		self.disconnectCallback()
		self.Connected = false
	end
end
local Signal
do
	Signal = setmetatable({}, {
		__tostring = function()
			return "Signal"
		end,
	})
	Signal.__index = Signal
	function Signal.new(...)
		local self = setmetatable({}, Signal)
		return self:constructor(...) or self
	end
	function Signal:constructor()
		self.connections = {}
		self.connectionsHandlersMap = {}
		self.lastFiredTick = 0
		self.isDestroyed = false
	end
	function Signal:Connect(onFiredCallback)
		if self.isDestroyed then
			error("Cannot connect to a destroyed signal")
		end
		local connection
		connection = SignalConnection.new(function()
			if not (self.connectionsHandlersMap[connection] ~= nil) then
				return nil
			end
			-- ▼ Map.delete ▼
			self.connectionsHandlersMap[connection] = nil
			-- ▲ Map.delete ▲
			do
				local i = 0
				local _shouldIncrement = false
				while true do
					if _shouldIncrement then
						i += 1
					else
						_shouldIncrement = true
					end
					if not (i < #self.connections) then
						break
					end
					if self.connections[i + 1] == connection then
						local _connections = self.connections
						local _i = i
						table.remove(_connections, _i + 1)
					end
				end
			end
		end)
		-- ▼ Map.set ▼
		self.connectionsHandlersMap[connection] = onFiredCallback
		-- ▲ Map.set ▲
		local _connections = self.connections
		-- ▼ Array.push ▼
		_connections[#_connections + 1] = connection
		-- ▲ Array.push ▲
		return connection
	end
	function Signal:disconnectAll()
		if self.isDestroyed then
			error("Cannot disconnect connections to a destroyed signal")
		end
		-- Clear the handlers mapping first so that we don't get an O(n^2) runtime complexity (see disconnect callback)
		-- ▼ Map.clear ▼
		table.clear(self.connectionsHandlersMap)
		-- ▲ Map.clear ▲
		do
			local i = 0
			local _shouldIncrement = false
			while true do
				if _shouldIncrement then
					i += 1
				else
					_shouldIncrement = true
				end
				if not (i < #self.connections) then
					break
				end
				self.connections[i + 1]:Disconnect()
			end
		end
		self.connections = {}
	end
	function Signal:destroy()
		if self.isDestroyed then
			return nil
		end
		self:disconnectAll()
		self.isDestroyed = true
	end
	function Signal:fire(...)
		local args = { ... }
		if self.isDestroyed then
			error("Cannot fire a destroyed signal")
		end
		self.lastFiredArgs = args
		self.lastFiredTick = tick()
		do
			local i = 0
			local _shouldIncrement = false
			while true do
				if _shouldIncrement then
					i += 1
				else
					_shouldIncrement = true
				end
				if not (i < #self.connections) then
					break
				end
				local _connectionsHandlersMap = self.connectionsHandlersMap
				local _arg0 = self.connections[i + 1]
				local handlerFunction = _connectionsHandlersMap[_arg0]
				if handlerFunction ~= nil then
					coroutine.wrap(handlerFunction)(unpack(args))
				end
			end
		end
	end
	function Signal:Wait()
		if self.isDestroyed then
			error("Cannot wait for a destroyed signal")
		end
		local lastFiredTickAtStart = self.lastFiredTick
		while self.lastFiredTick == lastFiredTickAtStart do
			RunService.Heartbeat:Wait()
		end
		-- eslint-disable-next-line
		return unpack(self.lastFiredArgs)
	end
end
return {
	Signal = Signal,
}
